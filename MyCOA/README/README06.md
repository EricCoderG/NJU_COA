# COA2022-programming06

> Good luck and have fun!



## 1 实验要求

在FPU类中实现2个方法，具体如下

1.计算两个浮点数真值的积 dest × src

``` java
 public DataType mul(DataType src, DataType dest)
```

2.计算两个浮点数真值的商 dest ÷ src

注意：除数为0，且被除数不为0时要求能够正确抛出ArithmeticException异常

``` java
 public DataType div(DataType src, DataType dest)
```



在NBCDU类中实现2个方法，具体如下

1.计算两个32位NBCD(8421码)的和，参数与返回结果为32位NBCD码。

``` java
 DataType add(DataType src, DataType dest)
```

2.计算两个32位NBCD(8421码)的差，dest表示被减数，src表示减数(即计算dest - src)

``` java
 DataType sub(DataType src, DataType dest)
```



## 2 实验指导

### 2.1 代码实现要求

本次实验中，我们仍然**明确禁止**各位采用直接转浮点数、十进制进行四则运算来完成本次实验。

### 2.2 代码实现流程

在充分掌握了浮点数的加减运算后，浮点数的乘除运算就十分简单了。其基本步骤和加法类似，相比加法运算，还可以免去对阶的过程。基本流程仍然可以分为以下四步：

1. 处理边界情况(NaN, 0, INF)
2. 提取符号、阶码、尾数
3. 模拟运算得到中间结果
4. 规格化并舍入后返回

#### 2.2.1 处理边界情况

在框架代码中，我们仍然提供了cornerCheck方法，使用正则表达式处理NaN的方法也同样适用，在此不再赘述。

注意，在除法运算中，还需要额外判断除数为0且被除数不为0的情况。

#### 2.2.2 提取符号、阶码、尾数

在本次作业中，我们使用IEE754浮点数运算标准，模拟32位单精度浮点数，符号位、指数部分与尾数部分分别为1、8、23位，同时使用3位保护位(GRS保护位)，大家经过简单操作即可完成这一步。

这一步有三个需要特殊处理的地方：

1. 当有一个操作数提取出的阶码为全1时，应该返回正无穷或负无穷，注意符号需要额外判断。（为什么？考虑无穷乘其他数的结果）
2. 当提取出的阶码为全0时，说明该操作数是一个非规格化数，此时应该对阶码+1使其真实值变为1，以保证后面的对阶操作不会出错。（为什么？可以考察IEEE754浮点数标准中阶码为0和阶码为1分别表示2的多少次方）
3. 在这一步中不要忘记尾数的最前面添加上隐藏位，规格化数为1，非规格化数为0。所以提取结束后尾数的位数应该等于1+23+3=27。

聪明的你是不是发现了，至此的所有操作都跟上次作业几乎一模一样。该怎么~~Ctrl C + Ctrl V~~操作就不用我多说了吧。

#### 2.2.3 模拟运算得到中间结果

乘除法运算对于符号位的计算非常简单，直接可以根据两个操作数的符号位得到结果的符号位，在此不作更深入的讲解。

对于阶码的计算，与加减法运算不同的是，乘除法运算不再需要对阶操作，而是直接计算结果阶码。其计算过程分别为

- 乘法：尾数相乘，阶码相加后减去偏置常数
- 除法：尾数相除，阶码相减后加上偏置常数

对于尾数的计算，在此需要大家分别实现27位无符号数的乘法与除法，运算流程可以参考课件。相信有了ALU的乘除法基础，这一步不会花费太多时间。

需要注意的是，对于27位乘法运算，返回的结果是54位的乘积。由于两个操作数的隐藏位均为1位，所以乘积的隐藏位为2位（为什么？）。为了方便后续操作，需要通过阶码加1的方式来间接实现小数点的左移，修正这个误差，以保证尾数的隐藏位均为1位。

#### 2.2.4 规格化并舍入后返回

在这一步中，我们仍然只要求大家进行规格化的处理。相比于加减法运算，乘除法的运算结果破坏规格化的情况更多，增加了阶码为负数的情况。简单分类如下：

1. 运算后54位尾数的隐藏位为0且阶码大于0，此时应该不断将尾数左移并将阶码减少，直至尾数隐藏位恢复为1或阶码已经减为0。
2. 运算后阶码小于0且54位尾数的前27位不全为0，此时应该不断将尾数右移并将阶码增加，直至阶码增加至0或尾数的前27位已经移动至全0。
3. 经过上述两步操作后，尾数基本恢复规格化，但阶码仍有可能破坏规格化，分为以下三种情况：
   - 阶码为"11111111"，发生阶码上溢，此时应该返回什么？
   - 阶码为0，则说明运算得到了非规格化数，此时应该将尾数额外右移一次，使其符合非规格化数的规范。（为什么？可以考察阶码为0000 0001，尾数为0.1000 0000 0000 0000 0000 0000 00的浮点数的规格化过程）
   - 阶码仍小于0，发生阶码下溢，此时又应该返回什么？

可能大家看到这里觉得很乱，没关系，我们提供的fpuMulTest9涵盖了这里面的所有情况，大家可以在debug的过程中体会其中的玄机。以上规格化过程可用伪代码表示如下：

```java
while (隐藏位 == 0 && 阶码 > 0) {
    尾数左移，阶码减1; // 左规
}
while (尾数前27位不全为0 && 阶码 < 0) {
    尾数右移，阶码加1; // 右规
}

if (阶码上溢) {
    将结果置为无穷;
} else if (阶码下溢) {
    将结果置为0;
} else if(阶码 == 0) {
	尾数右移一次化为非规格化数;
} else {
    此时阶码正常，无需任何操作;
}
```

对于规格化后的舍入操作，我们不要求掌握GRS保护位相关的舍入操作，感兴趣的同学可以阅读2.5节内容。我们依然提供了舍入操作的函数，方法签名如下

``` java
 private String round(char sign, String exp, String sig_grs) 
```

请注意，在调用此方法前，请确保你传入的参数已经进行了规格化，务必确保传入的符号位为1位，阶码为8位。可以传入位数大于等于27位的尾数，round函数会先取出前27位作为1位隐藏位+23位有效位+3位GRS保护位，剩余的所有位数都将舍入到保护位的最后一位中。

在此方法中，我们已经对GRS保护位进行了相应的处理并完成舍入，返回的结果即为32位的字符串，转化为DataType类型后即可进行返回。

至此，你已经完成了浮点数乘法的全部工作(・ω・)ノ

### 2.3 对浮点数除法的相关说明

浮点数除法和乘法的主要区别在第三步：模拟运算得到中间结果上面。由于27位尾数进行无符号除法后，得到的商也是27位的，已经符合了“1位隐藏位+23位有效位+3位保护位”的要求，所以不再需要额外的操作。

同时，也正是因为这个27位尾数的除法，得到的27位商的精度将会严重损失（为什么？）。因此，我们无法对除法运算提供像加减乘一样如此精心打磨的test9，也无法提供RandomTest。我们本可以通过一些额外的操作来改进这一步运算的精度（比如将尾数扩展至更多位数，进行运算前将被除数尽可能左移，将除数尽可能右移等），但考虑这会大幅增加作业难度，我们很遗憾地放弃了这个改进。

因此，由于精度限制，本次作业中的除法的所有用例都是规格化数，大家无需考虑非规格化数的情况。此外，由于大规模用例的缺失，为了让大家也能够拥有足够的测试用例对除法进行debug，我们只会隐藏很简单的一些用例，其余用例全部提供给大家。


